#!/usr/bin/env python3
import asyncio
import json
import uuid
import websockets
from datetime import datetime, timezone, timedelta

PORT = 2409
TZ_BEIJING = timezone(timedelta(hours=8))

# Keep track of all connected clients
connected = set()

# For each websocket, track which DataTransfer command to send next
next_dt_index = {}

# Keep track of BootReason unique IDs per client
boot_unique_ids = {}

def current_time() -> str:
    return datetime.now(TZ_BEIJING).isoformat()

async def handler(websocket, path=None):
    actual_path = websocket.request.path or "/"
    addr = websocket.remote_address
    allowed_paths = ["/CP_01", "/CP_02", "/CP_03", "/CP_04", "/CP_05", "/CP_06"]
    if actual_path not in allowed_paths:
        await websocket.close(code=1008)
        return

    suffix = actual_path
    print(f"[{current_time()}] (づ｡◕‿‿◕｡)づ Connected: {addr}{suffix}")
    connected.add(websocket)

    # Send TriggerMessage for CP_0x when connected
    if actual_path in allowed_paths:
        ws_unique_id = uuid.uuid4().hex
        trigger_msg = {
            "messageTypeId": 2,
            "messageId": ws_unique_id,
            "action": "TriggerMessage",
            "payload": {
                "requestedMessage": "StatusNotification",
                "evse": {"id": 1}
            }
        }
        text = json.dumps(trigger_msg)
        try:
            await websocket.send(text)
            print(f"[{current_time()}] ✨ Sent TriggerMessage CALL → {text!r}")
        except:
            connected.discard(websocket)
            return

    try:
        async for raw in websocket:
            ts = current_time()
            print(f"[{ts}] ► Received from {addr}{suffix}: {raw!r}")

            # ── Intercept plain "start"/"stop" commands ──
            cmd = raw.strip()
            if cmd in ("start", "stop", "get"):
                ws_unique_id = uuid.uuid4().hex
                if cmd == "start":
                    action = "RequestStartTransaction"
                    payload = {
                        "evse": {"id": 1},
                        "idToken": {"idToken": "ABC123", "type": "ISO14443"},
                        "chargingProfile": {
                            "id": 1,
                            "chargingSchedule": [{
                                "id": 1,
                                "chargingRateUnit": "A",
                                "chargingSchedulePeriod": [{
                                    "startPeriod": 0,
                                    "limit": 32.0
                                }]
                            }]
                        }
                    }
                elif cmd == "stop":
                    action = "RequestStopTransaction"
                    payload = {
                        "transactionId": "1"
                    }
                elif cmd == "get":
                    action = "TriggerMessage"
                    payload = {
                        "requestedMessage": "MeterValues",
                        "evse": {"id": 1}
                    }

                call_msg = {
                    "messageTypeId": 2,
                    "messageId": ws_unique_id,
                    "action": action,
                    "payload": payload
                }
                text = json.dumps(call_msg)
                dead = set()
                for ws in connected:
                    if ws.request.path == actual_path:
                        try:
                            await ws.send(text)
                        except:
                            dead.add(ws)
                for ws in dead:
                    connected.discard(ws)
                print(f"[{current_time()}] ✨ Sent {action} CALL → {text!r}")
                continue

            if cmd in ("getStatus1s", "getStatus5s"):
                ws_unique_id = uuid.uuid4().hex
                action = "DataTransfer"
                payload = {
                    "vendorId": "Totex",
                    "messageId": "1",
                    "data": {
                        "command": cmd,
                        "payload": {"ChargerID": actual_path.lstrip('/')}
                    }
                }
                call_msg = {
                    "messageTypeId": 2,
                    "messageId": ws_unique_id,
                    "action": action,
                    "payload": payload
                }
                text = json.dumps(call_msg)
                dead = set()
                for ws in connected:
                    if ws.request.path == actual_path:
                        try:
                            await ws.send(text)
                        except:
                            dead.add(ws)
                for ws in dead:
                    connected.discard(ws)
                print(f"[{current_time()}] ✨ Sent {action} CALL → {text!r}")
                continue

            # ── Broadcast incoming message to clients on the same path ─
            dead = set()
            for ws in connected:
                if ws is websocket or ws.request.path != actual_path:
                    continue
                try:
                    await ws.send(raw)
                except:
                    dead.add(ws)
            for ws in dead:
                connected.discard(ws)

            # Parse incoming message as JSON
            try:
                msg = json.loads(raw)
            except json.JSONDecodeError:
                print(f"[{ts}] ⚠️ Invalid JSON, skipping")
                continue

            # OCPP CALL: {"messageTypeId": 2, "messageId": str, "action": str, "payload": dict}
            if (
                isinstance(msg, dict)
                and msg.get("messageTypeId") == 2
                and "messageId" in msg
                and "action" in msg
                and "payload" in msg
            ):
                unique_id, action, payload = msg["messageId"], msg["action"], msg["payload"]

                try:
                    uid = int(unique_id)
                    prev = int(boot_unique_ids.get(websocket, 1))
                    if uid > prev:
                        boot_unique_ids[websocket] = uid
                except (ValueError, TypeError):
                    pass

                # Handle BootReason (replaces BootNotification)
                if action == "BootReason":
                    wss_call = {
                        "messageTypeId": 3,
                        "messageId": unique_id,
                        "payload": {
                            "currentTime": current_time(),
                            "status": "Accepted",
                            "interval": 10
                        }
                    }
                    wss_text = json.dumps(wss_call)
                    await websocket.send(wss_text)
                    print(f"[{ts}] ☆ Sent BootReason RES → {wss_text!r}")

                # Handle StatusNotification
                if action == "StatusNotification":
                    wss_call = {
                        "messageTypeId": 3,
                        "messageId": unique_id,
                        "payload": {}
                    }
                    wss_text = json.dumps(wss_call)
                    await websocket.send(wss_text)
                    print(f"[{ts}] ✿ Sent StatusNotification RES → {wss_text!r}")
                    if isinstance(payload, dict) and payload.get("connectorStatus") == "Finishing":
                        ws_unique_id = uuid.uuid4().hex
                        trigger_msg = {
                            "messageTypeId": 2,
                            "messageId": ws_unique_id,
                            "action": "TriggerMessage",
                            "payload": {
                                "requestedMessage": "StatusNotification",
                                "evse": {"id": 1}
                            }
                        }
                        trigger_text = json.dumps(trigger_msg)
                        try:
                            await websocket.send(trigger_text)
                            print(f"[{ts}] ✨ Sent TriggerMessage CALL → {trigger_text!r}")
                        except:
                            connected.discard(websocket)
                            return

                # Handle Heartbeat
                if action == "Heartbeat":
                    wss_call = {
                        "messageTypeId": 3,
                        "messageId": unique_id,
                        "payload": {"currentTime": current_time()}
                    }
                    wss_text = json.dumps(wss_call)
                    await websocket.send(wss_text)
                    print(f"[{ts}] ♥ Sent Heartbeat RES → {wss_text!r}")

                # Handle TransactionEvent (replaces StartTransaction/StopTransaction)
                if action == "TransactionEvent":
                    event_type = payload.get("eventType")
                    wss_call = {
                        "messageTypeId": 3,
                        "messageId": unique_id,
                        "payload": {
                            "transactionInfo": {
                                "transactionId": "1",
                                "chargingState": "Accepted" if event_type == "Started" else "Ended"
                            }
                        }
                    }
                    wss_text = json.dumps(wss_call)
                    await websocket.send(wss_text)
                    print(f"[{ts}] ╬ Sent TransactionEvent RES → {wss_text!r}")

                # Handle MeterValues
                if action == "MeterValues":
                    wss_call = {
                        "messageTypeId": 3,
                        "messageId": unique_id,
                        "payload": {}
                    }
                    wss_text = json.dumps(wss_call)
                    await websocket.send(wss_text)
                    print(f"[{ts}] Σ Sent MeterValues RES → {wss_text!r}")

                # Handle DataTransfer
                if action == "DataTransfer" and isinstance(payload, dict) and "data" in payload:
                    data = payload["data"]
                    if isinstance(data, str):
                        try:
                            data = json.loads(data)
                        except json.JSONDecodeError:
                            print(f"[{ts}] ⚠️ Invalid DataTransfer data JSON, skipping")
                            continue
                    if isinstance(data, dict) and data.get("command") in ["SetConverter", "SetRelay", "SetHMI", "SetLED"]:
                        wss_call = {
                            "messageTypeId": 2,
                            "messageId": unique_id,
                            "action": "DataTransfer",
                            "payload": {
                                "vendorId": "Totex",
                                "messageId": "1",
                                "data": {
                                    "command": data["command"],
                                    "payload": data.get("payload", {})
                                }
                            }
                        }
                        wss_text = json.dumps(wss_call)
                        await websocket.send(wss_text)
                        print(f"[{ts}] ✨ Sent {data['command']} CALL → {wss_text!r}")

    except websockets.exceptions.ConnectionClosed:
        pass
    finally:
        connected.discard(websocket)
        next_dt_index.pop(websocket, None)
        print(f"[{current_time()}] ╭(╯^╰)╮ Disconnected: {addr}{suffix} -- {len(connected)} remaining")

async def main():
    print(f"[{current_time()}] Starting ws://0.0.0.0:{PORT}")
    async with websockets.serve(handler, "0.0.0.0", PORT):
        await asyncio.Future()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nServer shut down by user.")
        
